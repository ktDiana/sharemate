- дать пользователям возможность бронировать вещи на определенные даты.
- добавьте зависимость spring-boot-starter-data-jpa и драйвер postgresql в файл pom.xml.

Создание базы данных - по таблице для каждой из основных сущностей, а также отзывы.
Напишите SQL-код для создания всех таблиц и сохраните его в файле resources/schema.sql — пока достаточно Item и User.

Настройка JPA: @Entity, @Table, @Column, @Id. Для поля status в классе Booking вам также пригодится @Enumerated.
Создайте репозитории для User и Item и доработайте сервисы, чтобы они работали с новыми репозиториями (???).

- Добавление запроса на бронирование. Запрос создан любым пользователем, подтверждён владельцем вещи. Эндпоинт — POST /bookings.
После создания запрос находится в статусе WAITING — «ожидает подтверждения».
- Подтверждение или отклонение запроса на бронирование владельцем вещи. Затем статус бронирования становится либо APPROVED, либо REJECTED.
Эндпоинт — PATCH /bookings/{bookingId}?approved={approved}, параметр approved может принимать значения true или false.
- Получение данных о конкретном бронировании (включая его статус). Либо автором бронирования, либо владельцем вещи. Эндпоинт — GET /bookings/{bookingId}.
- Получение списка всех бронирований текущего пользователя. Эндпоинт — GET /bookings?state={state}. Параметр state
необязательный и по умолчанию равен ALL (англ. «все»). Также он может принимать значения CURRENT (англ. «текущие»),
PAST (англ. «завершённые»), FUTURE (англ. «будущие»), WAITING (англ. «ожидающие подтверждения»), REJECTED
(англ. «отклонённые»). Бронирования должны возвращаться отсортированными по дате от более новых к более старым.
- Получение списка бронирований для всех вещей текущего пользователя. Эндпоинт — GET /bookings/owner?state={state}. Этот
запрос имеет смысл для владельца хотя бы одной вещи. Работа параметра state аналогична его работе в предыдущем сценарии.

- добавьте в модель данных сущность Booking и код для создания соответствующей таблицы в файл resources/schema.sql.

Создайте контроллер BookingController и методы для каждого из описанных сценариев.
!!! Подумайте, не нужно ли написать дополнительные DTO-классы для каких-то сценариев.

- полезно создать отдельное перечисление для возможных методов параметра state, ведь задачи этого перечисления могут
отличаться в слое представления (параметр для поиска) и в модели данных (состояние бронирования). wtffffff

- Добавление дат бронирования при просмотре вещей - чтоб владелец видел даты последнего и ближайшего следующего бронирования
для каждой вещи, когда просматривает список (GET /items).

Добавление отзывов - после того, как взяли вещь в аренду.
- таблица comments. Класс Comment, часть вещи, отдельный пакет для отзывов не нужен. Поместите класс в пакет item.
- комментарий можно добавить по эндпоинту POST /items/{itemId}/comment. Реализуйте логику по добавлению нового комментария
к вещи в сервисе ItemServiceImpl. Для этого также понадобится создать интерфейс CommentRepository.
- проверка, что пользователь, который пишет комментарий, действительно брал вещь в аренду.

- разрешить пользователям просматривать комментарии других пользователей по двум эндпоинтам — по GET /items/{itemId}
для одной конкретной вещи и по GET /items для всех вещей данного пользователя.

 Создание базы данных - Основные поля, которые нужно создать в таблицах, в целом аналогичны полям в уже реализованных сущностях:
 users: id, name, email
 items: id, name, description, is_available, owner_id, request_id (ключи записей в других таблицах (users и requests соответственно)).
 bookings: id, start_date, end_date, item_id, booker_id, status.
 requests: id, description, requestor_id.
 comments: id, text, item_id, author_id.

 - для дат использовать тип TIMESTAMP WITHOUT TIME ZONE
 - продумайте ограничения (CONSTRAINT) для таблиц.

- Добавьте параметры доступа к базе данных в файл application.properties. Их Spring будет использовать

 Переходите к созданию JPA-репозиториев — ваш проект будет работать с БД.
 Spring Data JPA позволяет автоматизировать создание DAO-классов в приложении — реализовать интерфейс репозитория.
 - Начните с пользователя. В пакете user создайте интерфейс UserRepository, наследующий интерфейс JpaRepository. Все базовые методы для
работы с данными, то есть чтение, сохранение, обновление, будут доступны пользователям этого интерфейса автоматически. Теперь вы можете внедрить
репозиторий в класс UserServiceImpl и заменить реализацию хранения данных в памяти на работу с БД.
 - Повторите для item — создайте интерфейс ItemRepository и теперь уже полноценно реализуйте в ItemServiceImpl все сценарии, которые вы наметили в
предыдущем спринте.
- добавить функцию поиска вещи. Причём переданный пользователем текст нужно искать как в названии, так и в описании. Этот шаг не реализуется
Spring автоматически, так что запрос для поиска придётся написать вручную.

 Подсказка: как написать SQL-запрос в репозитории - Необходимо декларировать метод поиска в интерфейсе репозитория, а также
указать текст нужного SQL-запроса с помощью аннотации @Query.
@Query(" select i from Item i " +
"where upper(i.name) like upper(concat('%', ?1, '%')) " +
"   or upper(i.description) like upper(concat('%', ?1, '%'))")
List<Item> search(String text);
Этот код не «чистый» SQL, а SQL-подобный язык. Он работает с сущностями модели данных, а не с полями таблицы: обратите внимание, например, на
конструкцию select i from Item i . Если имена полей модели и наименования полей в базе данных отличаются, в запросе необходимо указать именно поля
модели данных.
 Не забудьте добавить в код сервиса логические проверки: например, у пользователя не должно быть возможности создать вещь с пустым названием.
Запустите приложение и выполните несколько запросов. Сначала создайте пользователя. От его имени создайте новую вещь. Обновите её статус на
«недоступна для аренды» и обратно. Попробуйте найти эту вещь с помощью поиска и посмотреть подробную информацию о ней.

 Реализация функции бронирования - Создайте интерфейсы BookingService и BookingRepository, BookingServiceImpl

Для работы с бронированием понадобятся более сложные запросы в репозитории. Для части запросов придётся написать SQL-код вручную, как это
было с поиском вещи. Также пригодится ещё одна возможность Spring Data JPA. Вы можете создать в интерфейсе BookingRepository метод,
названный по конкретным правилам, а Spring автоматически сгенерирует его содержимое. Этот вариант полезен для запросов, которые
не покрываются стандартными CRUD-операциями, но при этом обладают достаточно простой логикой — например, найти запись по значению определённого поля.
 List<Booking> findByBooker_IdAndEndIsBefore(Long bookerId, LocalDateTime end, Sort sort);
Если добавить в репозиторий метод с таким определением, Spring сгенерирует метод, который будет осуществлять поиск всех записей по переданному
bookerId с датой окончания (поле end ) раньше переданной.

 Добавление дат бронирования при просмотре вещей - сначала доработайте DTO-класс, который возвращает пользователю при
 просмотре списка его вещей. Добавьте в класс две записи с датами бронирования. Обратите внимание: теперь объект вещи,
 который возвращается пользователю по эндпоинту GET /items и по GET /items/{itemId} , отличается. Поэтому правильнее
 будет создать отдельный DTO-класс для каждого из этих запросов.

- доработайте слой сервиса и репозиториев - объект Item - @ManyToOne и храним в бронировании ссылку на соответствующую Item.
 Поэтому для реализации получения дат бронирования вам нужно выполнить дополнительный запрос в репозиторий бронирований.
 Добавьте в BookingRepository метод, получающий бронирования для определённой вещи.
Booking содержит ссылку на Item , так что всё получится. Вызовите этот метод внутри сервиса ItemServiceImpl , а затем
вручную добавьте в результирующий DTO-объект нужные данные. Для этого внедрите BookingRepository в класс ItemServiceImpl.

Добавление отзывов - отзыв относится к одной вещи, а вот вещь может иметь много комментариев, поэтому вы будете хранить в
Comment ссылку на Item, но в Item ссылок на Comment не будет. Comment будет содержать следующие поля:
 id — уникальный идентификатор комментария;
 text — содержимое комментария;
 item — вещь, к которой относится комментарий;
 author — автор комментария;
 created — дата создания комментария.
 Теперь дайте пользователям возможность оставлять отзыв на вещь. Отзыв может оставить только тот пользователь, который
 брал эту вещь в аренду, и только после окончания срока аренды. Так комментарии будут честными. Добавление комментария
 будет происходить по эндпоинту POST /items/{itemId}/comment .
 Это единственный эндпоинт для работы с отзывами — разместите его в ItemController. Создавать отдельный контроллер не
 потребуется: это было бы уместно в приложении с более продвинутым функционалом отзывов. А вот написать DTO-класс для
 комментария нужно.
 - для получения списка из БД реализуйте обращение к новому репозиторию CommentRepository в соответствующих методах в
ItemServiceImpl . Вероятно, вам также захочется добавить в CommentRepository новые методы для поиска комментариев к вещи.

я в афиге